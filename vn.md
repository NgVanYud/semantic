### Đặc điểm kỹ thuật đánh phiên bản mang ý nghĩa (SemVer)
Các tư khóa “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” trong tài liệu này được giải thích trong [RFC 2119](http://tools.ietf.org/html/rfc2119).

1. [](https://semver.org/#spec-item-1) Phần mềm sử dụng Semantic Versioning MUST khai báo một công khai API. API này có thể được khai báo trong code hoặc tồn tại trong tài liệu. Tuy nhiên khi nó đã được hoàn thành thì nó cần phải chính xác và toàn diện.
2. [](https://semver.org/#spec-item-2) một chỉ số đánh dấu phiên bản MUST có dạng X.Y.Z, trong đó, X, Y, Z là các sô nguyên không âm, và MUST NOT bắt đầu bằng các số 0. X là phiên bản chính, Y là phiên bản phụ, Z là bản vá lỗi. Mỗi phần tử MUST tăng theo số thứ tự. Ví dụ 1.9.0 -> 1.10.0 -> 1.11.0 

3. [](https://semver.org/#spec-item-3) Khi mà một phiên bản package được phát hành, nội dung của phiên bản đó MUST NOT sửa đổi. Bất kỳ những thay đổi nào MUST được phát hành trong một phiên bản mới.

4. [](https://semver.org/#spec-item-4) Phiên bản chính zero (0.y.z) sử dụng cho việc phát triển ban đầu. Mọi thứ đều có thể thay đổi bất cứ khi nào. API public không được coi là ổn định.
5. [](https://semver.org/#spec-item-5) Phiên bản 1.0.0 mô tả API public.  Cách thức mà số hiệu phiên bản được tăng lên sau bản phát hành này phụ thuộc vào API public này và cách nó thay đổi.
6. [](https://semver.org/#spec-item-6) Bản vá lỗi Z (x.y.Z | x > 0) MUST được tăng lên chỉ khi các lỗi được công khai. Việc sửa lỗi được coi như là thay đổi nội bộ để khắc phục hành vi không chính xác. 
7. [](https://semver.org/#spec-item-7) Phiên bản phụ Y (x.Y.z | x > 0) MUST được tăng chỉ khi những tính năng mới và tương thich được giưới thiệu trong API public. Nó cũng MUST được tăng lên nếu bất kỳ chức năng API công khai nào được đánh dấu là không dùng nữa. Nó MAY được tăng lên nếu tính năng mới hoặc cải tiến đáng kể được giới thiệu trong các đoạn mã nguồn đóng. Nó cũng MAY bao gồm những thay đổi vá lỗi. Chỉ số phiên bản vá lỗi phải được thiết lập lại bằng 0 khi chỉ số phiên bản phụ tăng.
8. [](https://semver.org/#spec-item-8) Chỉ số phiên bản chính X (X.y.z | X > 0) MUST được tăng khi có bất kỳ sự thay đổi nào được giưới thiệu trong API public. Nó MAY bao gồm những thay đổi ở mức vá lỗi và mức phiên bản phụ. Chỉ số phiên bản phụ và vá lỗi MUST được thiết lập về 0 khi mà chỉ sô phiên bản chính được tăng.
9. [](https://semver.org/#spec-item-9) Một phiên bản được phát hành trước đó MAY được biểu thị bằng cách thêm dấu nối và một chuỗi định danh gồm các ký hiệu được phân tách bằng dấu chấm, chuỗi này được đặt sau chỉ số phiên bản vá lỗi. Chuỗi định danh này MUST bao gồm các chữ cái trong bảng mã ASCII và đầu gạch nối [0-9A-Za-z-]. Chuỗi định danh MUST NOT bỏ trống. Định danh dạng số MUST NOT chứa các số 0 ở đầu. Các phiên bản phát hành trước đó có mức ưu tiên thấp hơn phiên bản bình thường. Một phiên bản phát hành trước cho thấy rằng phiên bản này không ổn định và có thể không đáp ứng các yêu cầu về tính tương thích dự định được biểu thị trong phiên bản chính thức liên quan với nó. Ví dụ: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
10. [](https://semver.org/#spec-item-10) Xây dựng siêu dữ liệu MAY được biểu thị bằng cách nối thêm ký hiệu + và một chuỗi các định danh được ngăn cách nhau bằng dấu chấm (.), các chuỗi này đặt ngay sau phần chỉ số phiên bản vá lỗi hoặc chỉ số phiên bản phát hành trước. Các chuỗi định danh này MUST bao gồm các chữ cái trong bảng mã ASCII và đầu gạch nối [0-9A-Za-z-]. Chuỗi định danh MUST NOT bỏ trống. Xây dựng siêu dữ liệu SHOULD bỏ qua khi xác định ưu tiên phiên bản. Vì vậy, hai phiên bản chỉ khác nhau trong xây dựng siêu dữ liệu nhưng có cùng mức ưu tiên. Ví dụ: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.

11. [](https://semver.org/#spec-item-11) Sự ưu tiên đề cập đến cách các phiên bản được so sánh với nhau khi được yêu cầu. Ưu tiên MUST được tính bằng cách tách chỉ số phiên bản theo thứ tự thành các chỉ số con: chỉ số nhận dạng version chính, version phụ, version vá lỗi và chuỗi các định danh phiên bản phát hành trước (Xây dựng siêu dữ liệu không ảnh hưởng tới độ ưu tiên). Mức độ ưu tiên được xác định bởi sự khác biệt đầu tiên khi so sánh từng mã nhận diện từ trái sang phải như sau: Các chỉ số phiên bản chính, phiên bản phụ và phiên bả vá lỗi luôn được so sánh bằng số. Ví dụ : 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Khi mà 3 chỉ số trên bằng nhau thì chỉ số phiên bản được phát hành trước có độ ưu tiên thấp hơn với một phiên bản thông thường. Ví dụ: 1.0.0-alpha < 1.0.0. Mức độ ưu tiên đối với hai phiên bản phát hành trước giống nhau cả về chỉ sôs phiên bản chính, phiên bản phụ và vá lỗi MUST được xác định bằng cách so sánh mỗi mã định danh theo chiều từ trái sang phải cho đến khi thấy có sự khác biệt như sau: các định danh chỉ bao gồm các chữ số được so sánh về số lượng và các định danh mà bao gồm cả các chữ cái hoặc dấu gạch nối được so sánh theo thứ tự sắp xếp của ASCII. Các định danh số luôn luôn có độ ưu tiên thấp hơn các số định danh không phải là số. Một tập lớn các trường chỉ số phát hành trước có mức ưu tiên cao hơn một tập nhỏ hơn, nếu tất cả các định danh đứng trước đó đều bằng nhau. Ví dụ: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
### Tại sao phải sử dụng kỹ thuật đánh phiên bản mang ý nghĩa?
Đây không phải là một ý tưởng mới hay một cuộc cách mạng gì cả. Trên thực tế, có thể bạn đã làm gì đó gần như thế. Vấn đề là điều "gần như" không đủ tốt. Nếu không tuân thủ một số loại đặc tả chính thức, số phiên bản chủ yếu coi là không có ích trong việc quản lý các thành phần phụ thuộc. Bằng cách đặt tên và định nghĩa rõ ràng cho những ý tưởng trên, sẽ dễ dàng để truyền đạt ý định của bạn cho những người sử dụng phần mềm của bạn. Một khi các ý định này là rõ ràng, thì có thể tạo ra các chỉ số phụ thuộc linh hoạt (nhưng không quá linh hoạt).

Một ví dụ đơn giản sẽ cho thấy cách phiên bản ngữ nghĩa biến những khó khăn của trong quản lý các thành phần phụ thuộc chỉ còn là của quá khứ như nào. Hãy đọc qua thư viện 'Firetruck'. Nó đòi hỏi một package được gán phiên bản có tên là "Ladder". Vào thời điểm Firetruck được tạo ra, Ladder ở phiên bản 3.1.0. Vì Firetruck sử dụng một số tính năng đã được giới thiệu lần đầu tiên trong 3.1.0, bạn có thể xác định một cách an toàn rằng Ladder sẽ có phiên bản lớn hơn hoặc bằng 3.1.0 nhưng nhỏ hơn 4.0.0. Bây giờ, khi Ladder phiên bản 3.1.1 và 3.2.0 trở nên có sẵn, bạn có thể thêm chúng vào hệ thống quản lý gói và biết rằng chúng sẽ tương thích với phần mềm hiện tại.

Là một nhà phát triển có trách nhiệm, bạn sẽ, tất nhiên, muốn xác thưc bất kỳ chức năng nâng cấp gói nào được đưa ra. Thế giới thực là một nơi lộn xộn; chúng ta có thể không làm điều gì cả nhưng hãy cảnh giác. Những gì bạn có thể làm là để cho kỹ thuật đánh phiên bản có ý nghĩa cung cấp cho bạn một cách rõ ràng để phát hành và nâng cấp các gói mà không cần phải chạy theo các bản mới của các package phụ thuộc, tiết kiệm thời gian và rắc rối.

Nếu tất cả đều đồng ý, tất cả những gì bạn cần làm để bắt đầu sử dụng kỹ thuật đánh phiên bản có ý nghĩa là nói rằng bạn đang làm như vậy và sẽ tuân theo các quy tắc này về sau nữa. Liên kết tới trang web trong file README của bạn để những người khác biết các quy tắc và có thể đem lại lợi ích cho họ.
